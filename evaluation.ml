(*
                          CS 51 Final Project
                          MiniML -- Evaluation
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
*)

open Expr
open List
open Printf

(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string

(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException

(*......................................................................
  Environments and values
*)

module type ENV = sig
  (* the type of environments *)
  type env

  (* the type of values (including closures) stored in
     environments *)
  type value = Val of expr | Closure of (expr * env)

  (* empty () -- Returns an empty environment *)
  val empty : unit -> env

  (* close expr env -- Returns a closure for `expr` and its `env` *)
  val close : expr -> env -> value

  (* lookup env varid -- Returns the value in the `env` for the
     `varid`, raising an `Eval_error` if not found *)
  val lookup : env -> varid -> value

  (* extend env varid loc -- Returns a new environment just like
     `env` except that it maps the variable `varid` to the `value`
     stored at `loc`. This allows later changing the value, an
     ability used in the evaluation of `letrec`. To make good on
     this, extending an environment needs to preserve the previous
     bindings in a physical, not just structural, way. *)
  val extend : env -> varid -> value ref -> env

  (* env_to_string env -- Returns a printable string representation
     of environment `env` *)
  val env_to_string : env -> string

  (* value_to_string ?printenvp value -- Returns a printable string
     representation of a value; the optional flag `printenvp`
     (default: `true`) determines whether to include the environment
     in the string representation when called on a closure *)
  val value_to_string : ?printenvp:bool -> value -> string
end

module Env : ENV = struct
  type env = (varid * value ref) list

  and value = Val of expr | Closure of (expr * env)

  let empty () : env = []

  let close (exp : expr) (env : env) : value = Closure (exp, env)

  let lookup (env : env) (varname : varid) : value =
    try !(snd (List.find (fun (v_name, _) -> v_name = varname) env))
    with Not_found -> raise (EvalError "unbound variable")

  (* if varname already has a mapping in env, replace it with the new mapping *)
  let extend (env : env) (varname : varid) (loc : value ref) : env =
    (varname, loc) :: List.filter (fun (v_name, _) -> v_name <> varname) env

  let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
    match v with
    | Val exp -> exp_to_concrete_string exp
    | Closure (exp, env) ->
        if printenvp then
          sprintf "[%s |- %s]" (env_to_string env) (exp_to_concrete_string exp)
        else exp_to_concrete_string exp

  and env_to_string (env : env) : string =
    List.fold_left
      (fun acc (v_name, v_ref) ->
        acc ^ sprintf "{%s -> %s}" v_name (value_to_string !v_ref))
      "" env
end

(*......................................................................
  Evaluation functions

  Each of the evaluation functions below evaluates an expression `exp`
  in an environment `env` returning a result of type `value`. We've
  provided an initial implementation for a trivial evaluator, which
  just converts the expression unchanged to a `value` and returns it,
  along with "stub code" for three more evaluators: a substitution
  model evaluator and dynamic and lexical environment model versions.

  Each evaluator is of type `expr -> Env.env -> Env.value` for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures).

  DO NOT CHANGE THE TYPE SIGNATURES OF THESE FUNCTIONS. Compilation
  against our unit tests relies on their having these signatures. If
  you want to implement an extension whose evaluator has a different
  signature, implement it as `eval_e` below. *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)

let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp

let unop_eval (u : unop) (v : Env.value) : Env.value =
  match v with
  | Env.Val (Num n) -> ( match u with Negate -> Env.Val (Num ~-n))
  | _ -> raise (EvalError "can only negate a num")

let binop_eval (b : binop) (v1 : Env.value) (v2 : Env.value) : Env.value =
  match (v1, v2) with
  | Env.Val (Num n1), Env.Val (Num n2) -> (
      match b with
      | Plus -> Env.Val (Num (n1 + n2))
      | Minus -> Env.Val (Num (n1 - n2))
      | Times -> Env.Val (Num (n1 * n2))
      | Equals -> Env.Val (Bool (n1 = n2))
      | LessThan -> Env.Val (Bool (n1 < n2))
      | Concat -> raise (EvalError "integers cannot be concatenated"))
  | Env.Val (Bool b1), Env.Val (Bool b2) -> (
      match b with
      | Plus | Minus | Times | Concat ->
          raise
            (EvalError
               "booleans cannot be added, subtracted, multiplied, or \
                concatenated")
      | Equals -> Env.Val (Bool (b1 = b2))
      | LessThan -> Env.Val (Bool (b1 < b2)))
  | Env.Val (String s1), Env.Val (String s2) -> (
      match b with
      | Plus | Minus | Times ->
          raise (EvalError "strings cannot be added, subtracted, or multiplied")
      | Equals -> Env.Val (Bool (s1 = s2))
      | LessThan -> Env.Val (Bool (s1 = s2))
      | Concat -> Env.Val (String (s1 ^ s2)))
  | _ -> raise (EvalError "invalid use of binary operator")

(* The SUBSTITUTION MODEL evaluator *)

let rec eval_s (exp : expr) (_env : Env.env) : Env.value =
  match exp with
  | Num _ | Bool _ | Fun _ | Unassigned | String _ -> Env.Val exp
  | Var v -> raise (EvalError ("unbound variable " ^ v))
  | Raise -> raise EvalException
  | Unop (u, e) -> unop_eval u (eval_s e _env)
  | Binop (b, e1, e2) -> binop_eval b (eval_s e1 _env) (eval_s e2 _env)
  | App (e1, e2) -> (
      match eval_s e1 _env with
      | Env.Val (Fun (v, e)) -> eval_s (subst v e2 e) _env
      | _ -> raise (EvalError "only functions can be applied"))
  | Conditional (e1, e2, e3) -> (
      match eval_s e1 _env with
      | Env.Val (Bool b) -> if b then eval_s e2 _env else eval_s e3 _env
      | _ -> raise (EvalError "condition must be a boolean"))
  | Let (v, e1, e2) -> eval_s (subst v e1 e2) _env
  | Letrec (v, e1, e2) ->
      eval_s (subst v (subst v (Letrec (v, e1, Var v)) e1) e2) _env

(* The DYNAMICALLY-SCOPED and LEXICALLY-SCOPED ENVIRONMENT MODEL evaluators *)

module type ENV_SCOPE = sig
  val f : Env.env -> expr -> Env.value

  val app :
    Env.env -> expr -> expr -> (expr -> Env.env -> Env.value) -> Env.value

  val letrec :
    Env.env ->
    varid ->
    expr ->
    expr ->
    (expr -> Env.env -> Env.value) ->
    Env.value
end

module EnvDynamic : ENV_SCOPE = struct
  let f _env exp = Env.Val exp

  let app env e1 e2 eval =
    match eval e1 env with
    | Env.Val (Fun (v, e)) ->
        let v_q = eval e2 env in
        let new_env = Env.extend env v (ref v_q) in
        eval e new_env
    | _ -> raise (EvalError "only functions can be applied")

  let letrec env v e1 e2 eval =
    let v_d = eval e1 env in
    let new_env = Env.extend env v (ref v_d) in
    eval e2 new_env
end

module EnvLexical : ENV_SCOPE = struct
  let f env exp = Env.close exp env

  let app env e1 e2 eval =
    match eval e1 env with
    | Env.Closure (Fun (v, e), env_l) ->
        let v_q = eval e2 env in
        let new_env = Env.extend env_l v (ref v_q) in
        eval e new_env
    | _ -> raise (EvalError "only functions can be applied")

  let letrec env v e1 e2 eval =
    let binding = ref (eval Unassigned env) in
    let e' = Env.extend env v binding in
    let v_d = eval e1 e' in
    binding := v_d;
    eval e2 e'
end

module type ENV_EVALUATOR = sig
  val eval : expr -> Env.env -> Env.value
end

(* a functor that returns an ENV_EVALUATOR using the scope
   manifested in the ENV_SCOPE argument *)
module MakeEnvEvaluator (Scope : ENV_SCOPE) : ENV_EVALUATOR = struct
  let rec eval (exp : expr) (env : Env.env) : Env.value =
    match exp with
    | Num _ | Bool _ | Unassigned | String _ -> Env.Val exp
    | Var v -> Env.lookup env v
    | Raise -> raise EvalException
    | Fun _ -> Scope.f env exp
    | Unop (u, e) -> unop_eval u (eval e env)
    | Binop (b, e1, e2) -> binop_eval b (eval e1 env) (eval e2 env)
    | App (e1, e2) -> Scope.app env e1 e2 eval
    | Conditional (e1, e2, e3) -> (
        match eval e1 env with
        | Env.Val (Bool b) -> if b then eval e2 env else eval e3 env
        | _ -> raise (EvalError "condition must be a boolean"))
    | Let (v, e1, e2) ->
        let v_d = eval e1 env in
        let new_env = Env.extend env v (ref v_d) in
        eval e2 new_env
    | Letrec (v, e1, e2) -> Scope.letrec env v e1 e2 eval
end

module D = MakeEnvEvaluator (EnvDynamic)
module L = MakeEnvEvaluator (EnvLexical)

let eval_d = D.eval

let eval_l = L.eval

(* The EXTENDED evaluator -- if you want, you can provide your
   extension as a separate evaluator, or if it is type- and
   correctness-compatible with one of the above, you can incorporate
   your extensions within `eval_s`, `eval_d`, or `eval_l`. *)

let eval_e _ = failwith "eval_e not implemented"

(* Connecting the evaluators to the external world. The REPL in
   `miniml.ml` uses a call to the single function `evaluate` defined
   here. Initially, `evaluate` is the trivial evaluator `eval_t`. But
   you can define it to use any of the other evaluators as you proceed
   to implement them. (We will directly unit test the four evaluators
   above, not the `evaluate` function, so it doesn't matter how it's
   set when you submit your solution.) *)

let evaluate = eval_l
